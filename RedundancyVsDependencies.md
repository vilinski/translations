# Избыточность и Зависимости: что хуже?

http://www.yosefk.com/blog/redundancy-vs-dependencies-which-is-worse.html


В программировании есть два существенные правила: 
1. Нужно минимизировать повторения и, в идеале, определять всякое знание лишь один раз. 
2. Нужно минимизировать зависимости - A должно зависеть от B, только если оно абсолютно необходимо. 

 Я думаю, что все другие соображения о внешней реальных виде - домен моделирования, удобство использования, задачи,
 платформы и т.д. Я также думаю, что я могу показать, как любая "хорошая" практика программирования в основном 
 направлена на минимизацию избыточностей, зависимостей, или их обоих сразу.  
 Я даже думаю, что вы можете отличить "хорошего" программиста от "плохого" только лишь по их отношению 
 к избыточности и зависимостям.  Хорошие ненавидят их, плохих это не волнует. 

 Если эта идея выглядит до идиотизма упрощенно, обратите внимание, что я имею в виду "способности программирования" 
 в узком смысле качества кода.  Я видел блестящих людей с невероятным знанием в алгоритмах, 
 которые при этом всеравно умудрялись писать ужасный код. Я пытался понять как такое может быть. 
 Общим знаменателем среди ними казалось то, что они просто не заботятся о повторности или зависимостях,
 или они даже не думали об этом как о чём-то негативном.  
 Все еще выглядит слишком упрощенно?  Тогда оставим их. Это не то, о чём я хочу поговорить. 

 Я хочу поговорить о тех случае, когда минимизация повторений противоречит минимизации зависимостей.  
 В основном это случаи повторного использования кода за пределами границ модуля.  
 Каков ваш выбор между двумя следующими вариантами:
 
 - Модули A и B, используют модуль C чтобы что-то делать, или 
 - делают это каждый раз самостоятельно.


 Одна поразительно тупая вещь в этом вопросе, это то что он сосредоточен вокруг расплывчатого термина "модуль".
 Тем не менее, "модуль" создаёт компромисс. Внутри модуля, конечно, вы конечно станете повторно использовать код, 
 без вопросов. Ну кто захочет парсить две опции командной строки в двух дублированных фрагментах кода, 
 когда можно навалять функцию? 

 С другой стороны, если два модуля парсят эти аргументы, мы все еще можем использовать нашу функцию, поместив её 
 в третий модуль.  Кроме того, мы можете поместив её в модуль с подобными функциями - "Util". 
 Который мы ласково назовём "Утиль" - помойка.
 Которому для работы нужна куча внешних библиотек, используемых для реализации некоторых из его полезных функций.
 Который с вечно неправильной конфигурацией, 
 Который с инициализацией вечно не в нужное время.  
 Ну вы знаете, который Util.

 Я считаю, что годы опыта имеет значение только с точки зрения знаний.
 На работе вы не учитесь в темпе студента очника.  
 Опыт основном делает две вещи: она воспитывает характер, и она разрушает характер.
 Показательный пример: молодой, страстный программист, как правило, очень рад сделать третий модуль, 
 и его не передергивает, когда он копается в мусорном ведре Util. Он обижается, когда их более опытные коллеги, 
 которые заметили, что от их последней "инфраструктурной" деятельности, тянет блевать.
 Это, показывает как сила опыта то-ли воспитывает, то-ли разрушает характер. Не знаю что именно. 

 Нет, серьезно.  Возьмём парсер командной строки.  
 Вам нужен общий синтаксис этих параметров, так?
 И вы хотите, например, чтобы некоторые из них принимали значения.  
 И эти значения могут быть string, и bool, и int.
 И числа могут быть в десятичном или шестнадцатеричном виде.
 А так же некоторыми значениями пользовательских типов. 
 И они могут иметь вспомогарельные опции.  
 И вам нужно сгенерировать help.
 И графический интерфейс.
 И читать их из конфигурационных файлов.
 И проверить легитимность каждой опций или их комбинаций 

 Конечно это не проблема. Даже довольно тривиально. (Если вы достаточно умны, всё тривиально,
 пока вы полностью не запутаетесь в сложности. И признаёте что запутались в сложности. 
 Только первое обычно требует времени, чтобы это произошло, а последнее может никогда не случиться.) 
 Есть люди посвятили несколько лучших месяцев своей молодости проблеме передачи аргументов.
 Пример: [XParam](http://xparam.sourceforge.net/) , который называет себя "Решение обработки параметров".  
 Занимает > 10K строк кода, когда я в последний раз проверял.
 Поставляется с собственным сериализатором. Говорят, что его основной проект использует <5% возможностей. 

 Уточнение: я не насмехаюсь над авторами XParam. 
 Причина 1: Есть слухи, что они довольно крутые ребята.  
 Причина № 2: Мне очень стыдно в этом признаться, но я когда-то работал над библиотечкой под названием XLog.
 Занимала более 10K строк в последний когда я считал.  Шел с собственным сериализатором.
 Из первых рук фактические данные свидетельствуют, что ее основной проект использует 0% возможностей.  Ой. 

 Вы знаете, как я сейчас анализирую командные строки в моих модулях?  Вот так: 
 
 ```с
  for(i=0; i<argc; ++i) {
  if(strcmp(argv[i],"-trace")==0) {
    trace=1;
  }
 }
 ```

 Я использовал C для примера, потому что это самый уродливый язык для обработки строк, и это ещё не всё.
 Нет, я не генерирую help.
 Нет, я не делаю проверки опций. Не судите меня. Это отладочные параметры. Мне хватает. 
 Лучше любого парсера в 10 тыщ строк. Не говоря уже об утилитах в 50 тыщ строк кода полной токсичных отходов. 

 Модули имеют важное значение. Граница модуля важна. 
 Модуль является частью программного обеспечения, который имеет: 
1. Достаточно компактный, стабильный интерфейс. Плохим побочным эффектом OO является то, 
что компактные интерфейсы не ценят. Объектная модель считаются нормальными, если она имеет десяток классов 
и волосатые структуры данных и непродуманными точками расширяемости. Кроме того, плохой побочный эффект классов С++ 
является то, что "стабильный интерфейс" это оксюморон.  Но неважно, ничто не мешает вам сделать 
компактной, стабильный интерфейс. 
2. Документацию. Семантика компактного и стабильного интерфейа где-то описана.  
Действительно хороший модуль поставляется с примерами кода.  "Внутренние" модули могут не иметь достаточно полную 
документацию, этого не всегда можно избежать. 
3. Тесты. Я не думаю, что модульного тестирование каждого класса или функции имеет смысл.  
Что должно быть проверено является "официальным" интерфейсы модуля, потому что, если они работают, 
весь модуль можно считать рабочим, в противном случае нельзя. 
4. Разумный размер модуля. Как правило 1K - 30K строк (цифры приведены для C++; 
для [4GL](http://en.wikipedia.org/wiki/4GL) языков, дели на 4)..  Более длинные модули это куча грязи.
Система, состоящая из огромного количества крошечных модулей тоже куча грязи. 
5. Владелец. Способ изменить модуль нужно убедить в этом владельца. Чтобы исправить ошибку нужно сообщить об этом 
владельцу.  Таким образом, вы можете рассчитывать на интерфейс, который будет подкреплён последовательной 
ментальная моделью, которая заставляет его работать.
Число людей, способных одновременно поддерживать такую ментальную модель экспериментально установлено равным 1. 
6. Жизненный цикл. Кроме исправления срочных ошибок, изменения в модуле группируются в версиях, 
которые не выпускаются слишком часто.  В противном случае вы не можете иметь проверенный, стабильный интерфейс. 

 Довольно тяжко. 

 Хочу ли я создать модуль для обработки командной строки?  
 Действительно ли я хочу стать заслуженным владельцем этого переднего края технологии?
 Спасибо, не сейчас. Конечно, без разговора, это было бы весело, и это было бы тривиально, правда.
 К счастью, не все вокруг ленивы и сварливы, как я. Видите? Тот парень уже создал такой модуль.
 И вот этот тоже. И что теперь, сделать мой код зависимым от них? 

 Сложный вопрос. Я уже скомпрометирован мою репутацию, отказываясь правильно применять парсер.
 Если теперь я откажусь использовать существующие решения в моём следующем модуле, я только подтвержу 
 асоциальный характер моей личности.  Где мой командный дух?  И все же, у меня есть сомнения.  
 Действительно ли это модуль? 

 Прежде всего, и это самый раздражающий из всех вопросов - кому принадлежит эта работа?  
 Конечно, вы думали, что это тривиально, и вы хакнули его. Но вы готовы поддерживать его, или у вас есть кто-то на виду,
 кого вы хотите перевести в собственность?  
 Вы, наверное, даже не понимаете, что он должен быть поддержан, 
 так как это настолько тривиально.  Да, но вы будете.  Вы поймете, что это должно быть поддержано. 

 Я достаточно прозорлив чтобы сказать, когда вы поймете, что это. Это будет, когда первый полный идиотизм внесения изменений в код кем-то другим.  Не исключено, связывая его в другую часть «инфраструктура», что привело к гордиев узел зависимостей.  Когда-нибудь замечали, как инфраструктура любителей всегда считают, что их модуль поставляется первым в цепочке продовольственной зависимости и как это в конечном счете вызывает циклические зависимости?  Так или иначе, то, вы поймете.  Конечно, это будет уже слишком поздно, насколько я могу судить.  Мой код был привязан к вашей, что принадлежит им, и всем остальным липкая инфраструктуры.  Oopsie. 

 (Наивный читатель может спросить, что может парсер командной строки возможно зависит от О, много материала сериализации пакета разбор пакета цветные терминала пакета ввода / вывода, для экранов помощи C + +:.... Платформы пакет для доступа к ARGC, агду перед Main () называется C + +:.. Синглтон управления пакетами инициализации WTF является то, что, спросите вы получите сумку блевать и узнать, что современный C + + Дизайн должен сказать по этому поводу)?. 

 Так что нет, я не хочу зависеть ни от чего без владельца. Я вижу, как это рассуждение может привести в бешенство.  Смещение фокуса от программного обеспечения до Wetware является подвоха любимы технически бессильной псевдо-бизнес-ориентированных менеджеров среднего звена типа неудачник.  Вот моя попытка различая себя от иже с ними: я не только хотят зависеть от вещи с хозяина, но я требую счастливого обладателя в этом.  В отличие от общих управленческих предположения (один из тех, которые редко выполняются, но держать менеджеров здравомыслящих), я не верю в принудительном присвоении собственности.  Если владелец не любит модуля, ожидают некоторые довольно паршивая работа садоводства. 

 Как насчет жизненного цикла?  Мой модули и модули ваш высвобождаются в разное время.  Я может столкнуться с необходимостью проверить на совместимость с различными версиями ваши вещи.  Мои тесты не будет компилироваться без вашего кода, так что теперь мне нужно, чтобы всегда иметь его в своей среде.  Что делает ваш код зависит - разве мало, стабильной, определенный набор вещей?  Я не хочу, чтобы застрять только потому, что ваша новая версия тащит в несколько зависимостей.  Что делать, если мне нужна функция?  Вы, кажется, не поддерживает чисел с плавающей точкой.  И я не вижу сокращения, либо, я нуждаюсь в них для связки причиной флагами "они прошли интерактивно все время. 

 Как насчет стабильного интерфейса и семантики?  Ваша предыдущая версия примет команду линии, проходящие ту же опцию несколько раз, и принять последнее значение.  У меня сценариев тестирования, на это рассчитывать.  Ваша новая версия выдает сообщение об ошибке, потому что сейчас этот синтаксис зарезервирован для списков (-Frob = Frob =-B-C = Frob проходит списка A, B, C, как стоимость опциона Frob).  Вздох.  Я предполагаю, что это могло быть и хуже - вы могли бы сделать строку "A, B, C" из этой командной строки, а затем эта проблема будет распространяться глубже. 

 Я мог бы продолжать и дальше, о том, как интерфейс не является достойной открытый интерфейс (вы не ожидаете, что я серьезно к подклассу EnumParser обрабатывать флаги с фиксированным набором допустимых значений строки, не так ли?).  Или о размере кода, который на данный момент карлики размером моего собственного модуля, так что я бы больше командной строки разбора кода, чем все остальное в моих тестах.  И как это больно, когда вы загрузите тесты используется медленное подключение к целевой машине.  И как я не люблю, когда мои краш-тесты внутри вашего кода, даже если это моя вина, потому что у вас волосатые структуры данных, которые мне не нравятся для проверки. 

 Но вы уже все поняли - я не хочу свой код, потому что я мудак антиобщественных, который не имеет командный дух вообще.  Я собираюсь разобрать аргументы, используя 5 строк кода C.  Хуже того, я сделаю функцию из этих пяти линий, префикс его имя с именем модуля, и повторить его во всех своих модулей.  Да, я копипаст программист и вы просвещенный разработчик платформы следующего поколения команды разбор линии.  Будь по-твоему, и я буду иметь это мой путь. 

 Для завершения плохое впечатление я делал здесь, я буду использовать недостатки реальные аналогии.  Подумайте живых организмов.  У них есть очень серьезные Вавилонская башня проблемы; избыточность во всем мире.  Я слышал, что люди и осьминоги имеют очень похожие структуры глаза, несмотря на то, является потомком от слепого предка.  Командная строка парсеры?  Целые глазами, а не простейшие часть оборудования с довольно нейронных сложности на фоновых, получить разработаны самостоятельно.  Избыточность вряд ли может стать еще хуже.  Но это работает, по-видимому лучше, чем усилия Координационного каждого развиваться будет работать. 

 Избыточность сосет.  Избыточность всегда означает дублирование усилий, а иногда и проблемы взаимодействия.  Но зависимостей хуже.  Единственным разумным шагом зависят, полноценный, реальный модуль, а не аморфную кучу кода.  Обычно вы можете посмотреть на проблему и угадать очень хорошо, если ее решение имеет хорошие шансы стать настоящим модулем, с реальным владельцем, со стабильным интерфейс, делающий всех его пользователей достаточно счастливым.  Если эти шансы низки, выбрать избыточности.  И оценить эти шансы консервативно, тоже.  Избыточность это плохо, но на самом деле зависимости могут парализовать вас.  Я говорю - убить первых зависимостей.
