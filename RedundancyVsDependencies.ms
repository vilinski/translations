# Избыточность и Зависимости: что хуже?

http://www.yosefk.com/blog/redundancy-vs-dependencies-which-is-worse.html


Я считаю, что есть только два сущностных сил в программировании: 
1. Вы хотите, чтобы минимизировать избыточность и, в идеале, определить всякое знание и один раз. 
2. Вы хотите, чтобы минимизировать зависимость - должно зависеть от B, только если оно абсолютно необходимо. 

 Я думаю, что все другие соображения о внешней реальных виде - домен моделирования, удобство использования, графики, платформы и т.д. Я также думаю, что я могу показать, как любой "хорошей" практики программирования в основном направлена ​​на минимизацию избыточности, зависимости, или обоих.  Я даже думаю, что вы можете сказать "хороший" программист из "плохих" один на их отношение к избыточности и зависимостей.  Хорошие ненавидят их, плохие не волнует. 

 Если эта идея выглядит идиотски упрощенно, обратите внимание, что я имею в виду "Программирование способностей» в узком смысле качества кода.  Я видел блестящую, кооперативных люди со сверхъестественной алгоритмических возможностей, которые все еще писал ужасные кода.  Я пытался понять его, и общий знаменатель, казалось, что они просто не заботятся о избыточность или зависимости, или даже своего рода нравились.  Может быть, это все еще выглядит идиотски упрощен.  Давайте оставим все как есть, потому что это не то, что я здесь, чтобы поговорить. 

 Я здесь, чтобы говорить о том случае, когда минимизация избыточности минимизации конфликтов с зависимостями.  Этот случай повторного использования кода в основном за пределами границы модулей.  Вы можете выбирать между наличием модулей А и В, используя модуль C что-то делать, или иметь их делать это самостоятельно.  Каков ваш звонок? 

 Один поразительно тупой вещь об этом вопросе является то, что она сосредоточена вокруг термина "модуль", который является расплывчатым и неформальные.  Тем не менее, "модуль", что делает этот компромисс.  Внутри модуля, конечно, вы хотите, чтобы повторно использовать код, в конце обсуждения.  Зачем кому-то хотите, чтобы разобрать две опции командной строки в два дублированных фрагментов кода, когда вы могли бы использовать функцию? 

 С другой стороны, если два модуля разбора аргументов командной линии, мы все еще ​​можем вынести за скобки разбора кода, но мы должны были бы сделать это в третий модуль.  Кроме того, мы можете наполнить его в "Утилиты" модуля.  Одна ласково называют "мусорной корзине".  Не тот, который свяжет без связки внешних библиотек, используемых для реализации некоторых из его полезных функций.  Тот, что с конфигурацией, которая всегда получает неправильно, и инициализации чего никогда не бывает в нужное время.  Вы знаете, модуль коммунальные услуги. 

 Я считаю, что опыт имеет значение только с точки зрения знаний.  Вы не узнаете на работе такими темпами, что в какой-либо из полный рабочий день студента.  Опыт основном делает две вещи: она воспитывает характер, и она разрушает характер.  Показательный пример: молодой, страстной программисты, как правило, очень счастливы сделать третий модуль, и они не передергивает, когда они вникать в утилиту мусорное ведро.  Они то понятно обижаются, когда их более опытные коллеги, которые заметили, что их последний "инфраструктурных" деятельность, протянуть руку для мешков блевать.  Это, конечно, показывает ни характер потенциала или характер-разрушительная сила опыта, я просто не знаю, какой именно. 

 Нет, серьезно.  Возьмите разбора командной строки.  Вы хотите, общий синтаксис этих параметров, не так ли?  И вы хотите, чтобы некоторые из них принимают значения, не так ли?  И эти ценности могут быть строками, и логические, и целые числа, не так ли?  И целых чисел может быть десятичное или шестнадцатеричное, верно?  И они могут быть значениями пользовательских типов, правильно?  И они могут получить помощь строк, не так ли?  И вы хотите, чтобы выдать справку экранов от них, не так ли?  И графического интерфейса с страницами свойств?  И читать их из файлов конфигурации?  И проверить законность флаги или наборы флагов, не так ли? 

 Конечно.  Это не имеет большого значения.  Тривиально, даже.  (Если вы умны, все тривиально пока вы не полностью из-за превышения сложности. И признаться, что вам не удалось из-за превышения сложности. Бывший нужно время, чтобы это произошло, оно никогда не может случиться.) Довольно некоторые люди посвятили несколько красивые месяцы своей молодости к проблеме передачи аргументов.  Пример: XParam , которая называет себя "Решение Обработка параметров".  Принял> 10K LOC последний раз я проверил.  Поставляется с собственным рамках сериализации.  Слухи говорят, что его первоначальный проект Хост использует <5% от своих возможностей. 

 Уточнение: я не насмешливые авторов XParam.  Причина 1: Слухи сказать, что они довольно острые.  Причина № 2: Я очень, очень стыдно в этом признаться, но я когда-то работал на геофизическом библиотеки под названием XLog.  Принял> 10K LOC в последний раз я насчитал.  Шел с собственными рамками сериализации.  Из первых рук фактические данные свидетельствуют, что ее хозяин проект использует 0% от своих возможностей.  Ой. 

 Вы знаете, как я анализирую аргументы командной строки в моей модулей в эти дни?  Вот так: 
  для (я = 0; I <ARGC; + + I) {
   Если (STRCMP (ARGV [I], "-следа") == 0) {
     проследить = 1;
   }
 } 

 Я использовал C для примера, потому что это самый уродливый язык для обработки строк, и это все еще кусок пирога.  Нет, я не получить помощь экранов.  Нет, я не получу соответствующей проверки командной строки.  Так подать иск против меня.  Они отладки.  Это достаточно хорошо.  Бьет того, все зависит от пакета 10K LOC линии разбора команды.  Не говоря уже о 50K LOC мусора утилита может полна токсичных отходов. 

 Модули имеют важное значение.  Модуль границы важны.  Модуль является частью программного обеспечения, который имеет: 
1. Достаточно плотными, стабильный интерфейс. Побочный эффект обучения OO является то, что компактная интерфейсы не ценят.  Считается, ОК, чтобы подвергать объектной модели с десятками классов и волосатые структур данных и непродуманной крючки расширяемости.  Кроме того, побочный эффект классов С + + является то, что "стабильный интерфейс" это оксюморон.  Но независимо от того, ничто не мешает вам осуществлении компактной, стабильный интерфейс. 
2. Документация. Семантике компактный и стабильный интерфейс описаны где-то.  Действительно хороший модуль поставляется с примерами кода.  "Внутренняя" модулей не хватает достаточно полную документацию сосать, хотя не всегда можно избежать. 
3. Тесты. Я не думаю, модульного тестирования каждого класса или функции имеет смысл.  Что должно быть проверено является "официальным" интерфейсы модуля, потому что, если они работают, весь модуль можно считать рабочим, в противном случае она не может. 
4. Разумный размер модуля правило, должен быть и между 1K 30K LOC (цифры приведены в C + + KLOC единиц; для 4GLs, разделить их на 4)..  Увеличенную модули кучу грязи.  Система, состоящая из огромного количества крошечных модулей сама кучу грязи. 
5. Владелец. Способ изменить модуль убедить хозяина, чтобы сделать изменения.  Способ исправить ошибку является сообщить об этом владельцу.  Таким образом, вы можете рассчитывать на интерфейс, который будет подкреплено последовательной ментальная модель заставить его работать.  Число людей, способных одновременно поддержание такой ментальной модели экспериментально установлено равным 1. 
6. Жизненного цикла. Кроме исправления чрезвычайных ошибка, изменения в модуле группируются в версиях, которые не выпускаются слишком часто.  В противном случае вы не можете иметь проверенный, стабильный интерфейс. 

 Довольно тяжелый. 

 Хочу ли я ввести модуль для обработки анализа опций командной строки?  Действительно ли я хочу стать заслуженным владелец этого передним краем технологии?  Не сейчас, спасибо.  Конечно, это выгорание говоря, это было бы весело, и это было бы тривиально, действительно.  К счастью, не все вокруг ленив и сварливой, как я.  Видите?  Тот парень уже создали анализа опций командной строки модуля.  И это лицо здесь сделал, тоже.  Теперь, я хочу, чтобы мой код зависеть от их вещи? 

 Сложный вопрос.  Я уже скомпрометирован мою репутацию, отказываясь правильно работать с командой разбор линии.  Если мой следующий ход отказывается использовать существующие решения, я буду доказали антиобщественного характера моей личности.  Где мой командный дух?  И все же, у меня есть сомнения.  Действительно ли это модуль? 

 Прежде всего, и это самый раздражающий из всех вопросов - кому принадлежит эта часть работы?  Конечно, вы думали, что это тривиальная, и вы взломали его.  Но вы готовы поддержать его, или у вас есть кто-то в виду, вы хотите перевести в собственность?  Вы, наверное, даже не понимает, что он должен быть поддержан, так как это настолько тривиально.  Да, но вы будете.  Вы поймете, что это должно быть поддержано. 

 Я достаточно Кассандра точно сказать, когда вы поймете, что это.  Это будет, когда первый полный идиотизм внесения изменений в код кем-то другим.  Не исключено, связывая его в другую часть «инфраструктура», что привело к гордиев узел зависимостей.  Когда-нибудь замечали, как инфраструктура любителей всегда считают, что их модуль поставляется первым в цепочке продовольственной зависимости и как это в конечном счете вызывает циклические зависимости?  Так или иначе, то, вы поймете.  Конечно, это будет уже слишком поздно, насколько я могу судить.  Мой код был привязан к вашей, что принадлежит им, и всем остальным липкая инфраструктуры.  Oopsie. 

 (Наивный читатель может спросить, что может парсер командной строки возможно зависит от О, много материала сериализации пакета разбор пакета цветные терминала пакета ввода / вывода, для экранов помощи C + +:.... Платформы пакет для доступа к ARGC, агду перед Main () называется C + +:.. Синглтон управления пакетами инициализации WTF является то, что, спросите вы получите сумку блевать и узнать, что современный C + + Дизайн должен сказать по этому поводу)?. 

 Так что нет, я не хочу зависеть от ничего без владельца.  Я вижу, как это рассуждение может привести в бешенство.  Смещение фокуса от программного обеспечения до Wetware является подвоха любимы технически бессильной псевдо-бизнес-ориентированных менеджеров среднего звена типа неудачник.  Вот моя попытка различая себя от иже с ними: я не только хотят зависеть от вещи с хозяина, но я требую счастливого обладателя в этом.  В отличие от общих управленческих предположения (один из тех, которые редко выполняются, но держать менеджеров здравомыслящих), я не верю в принудительном присвоении собственности.  Если владелец не любит модуля, ожидают некоторые довольно паршивая работа садоводства. 

 Как насчет жизненного цикла?  Мой модули и модули ваш высвобождаются в разное время.  Я может столкнуться с необходимостью проверить на совместимость с различными версиями ваши вещи.  Мои тесты не будет компилироваться без вашего кода, так что теперь мне нужно, чтобы всегда иметь его в своей среде.  Что делает ваш код зависит - разве мало, стабильной, определенный набор вещей?  Я не хочу, чтобы застрять только потому, что ваша новая версия тащит в несколько зависимостей.  Что делать, если мне нужна функция?  Вы, кажется, не поддерживает чисел с плавающей точкой.  И я не вижу сокращения, либо, я нуждаюсь в них для связки причиной флагами "они прошли интерактивно все время. 

 Как насчет стабильного интерфейса и семантики?  Ваша предыдущая версия примет команду линии, проходящие ту же опцию несколько раз, и принять последнее значение.  У меня сценариев тестирования, на это рассчитывать.  Ваша новая версия выдает сообщение об ошибке, потому что сейчас этот синтаксис зарезервирован для списков (-Frob = Frob =-B-C = Frob проходит списка A, B, C, как стоимость опциона Frob).  Вздох.  Я предполагаю, что это могло быть и хуже - вы могли бы сделать строку "A, B, C" из этой командной строки, а затем эта проблема будет распространяться глубже. 

 Я мог бы продолжать и дальше, о том, как интерфейс не является достойной открытый интерфейс (вы не ожидаете, что я серьезно к подклассу EnumParser обрабатывать флаги с фиксированным набором допустимых значений строки, не так ли?).  Или о размере кода, который на данный момент карлики размером моего собственного модуля, так что я бы больше командной строки разбора кода, чем все остальное в моих тестах.  И как это больно, когда вы загрузите тесты используется медленное подключение к целевой машине.  И как я не люблю, когда мои краш-тесты внутри вашего кода, даже если это моя вина, потому что у вас волосатые структуры данных, которые мне не нравятся для проверки. 

 Но вы уже все поняли - я не хочу свой код, потому что я мудак антиобщественных, который не имеет командный дух вообще.  Я собираюсь разобрать аргументы, используя 5 строк кода C.  Хуже того, я сделаю функцию из этих пяти линий, префикс его имя с именем модуля, и повторить его во всех своих модулей.  Да, я копипаст программист и вы просвещенный разработчик платформы следующего поколения команды разбор линии.  Будь по-твоему, и я буду иметь это мой путь. 

 Для завершения плохое впечатление я делал здесь, я буду использовать недостатки реальные аналогии.  Подумайте живых организмов.  У них есть очень серьезные Вавилонская башня проблемы; избыточность во всем мире.  Я слышал, что люди и осьминоги имеют очень похожие структуры глаза, несмотря на то, является потомком от слепого предка.  Командная строка парсеры?  Целые глазами, а не простейшие часть оборудования с довольно нейронных сложности на фоновых, получить разработаны самостоятельно.  Избыточность вряд ли может стать еще хуже.  Но это работает, по-видимому лучше, чем усилия Координационного каждого развиваться будет работать. 

 Избыточность сосет.  Избыточность всегда означает дублирование усилий, а иногда и проблемы взаимодействия.  Но зависимостей хуже.  Единственным разумным шагом зависят, полноценный, реальный модуль, а не аморфную кучу кода.  Обычно вы можете посмотреть на проблему и угадать очень хорошо, если ее решение имеет хорошие шансы стать настоящим модулем, с реальным владельцем, со стабильным интерфейс, делающий всех его пользователей достаточно счастливым.  Если эти шансы низки, выбрать избыточности.  И оценить эти шансы консервативно, тоже.  Избыточность это плохо, но на самом деле зависимости могут парализовать вас.  Я говорю - убить первых зависимостей.
